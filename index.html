<!doctype html><html lang="fi"><meta charset="utf-8">
<title>LEMP-demo</title>

<style>
  html, body {
    height: 100%;
    margin: 0;
  }

  body {
    font-family: system-ui;
    display: flex;
    flex-direction: column;
    align-items: center;
    text-align: center;
    background: #f8f9fa;
    line-height: 1.2;
    overflow: hidden;        /* estää sivun vierityksen */
  }

  h1 {
    margin: 0.5rem 0 0.25rem 0;
  }

  p {
    font-size: 1.25rem;
    margin: 0.3rem 0;
  }

  .time {
    font-weight: 700;
    color: #007bff;
    font-size: 1.5rem;
  }

  img {
    margin-top: 0.5rem;
    max-width: 90%;
    height: auto;
  }

  #scoreboard {
    margin-top: 0.5rem;
    font-weight: 600;
    font-size: 1rem;
  }

  canvas#game {
    margin-top: 0.5rem;
    border: 1px solid #ccc;
    background: #fff;
    width: 40vw;   /* täyttää lähes koko leveydeltä */
    height: 40vw;  /* pitää neliön muodon */
    max-width: 300px;
    max-height: 300px;
  }

@keyframes bgshift {
  0%   { background-position: 0% 50%; }
  50%  { background-position: 100% 50%; }
  100% { background-position: 0% 50%; }
}

body {
  background: linear-gradient(270deg, #74b9ff, #81ecec, #55efc4, #ffeaa7, #fab1a0, #ff7675);
  background-size: 1200% 1200%;
  animation: bgshift 20s ease infinite;
}

#spede {
    margin-top: .5rem;
    display: grid;
    grid-template-columns: repeat(3, 70px);
    grid-template-rows: repeat(3, 70px);
    gap: 8px;
    justify-content: center;
    align-items: center;
  }
  /* sijoitus: ylös, vasen, oikea, alas ristikkoon */
  #spede .cell[data-dir="UP"]    { grid-column: 2; grid-row: 1; }
  #spede .cell[data-dir="LEFT"]  { grid-column: 1; grid-row: 2; }
  #spede .cell[data-dir="RIGHT"] { grid-column: 3; grid-row: 2; }
  #spede .cell[data-dir="DOWN"]  { grid-column: 2; grid-row: 3; }

  #spede .cell {
    user-select: none;
    display: flex; align-items: center; justify-content: center;
    border: 2px solid #ccc; border-radius: 10px;
    font-size: 28px; width: 70px; height: 70px;
    background: #fff; cursor: pointer; transition: transform .05s;
  }
  #spede .cell.active { border-color: #007bff; box-shadow: 0 0 10px rgba(0,0,0,.1); transform: scale(1.05); }
  #spede .cell.good   { background: #d1e7dd; border-color: #198754; }
  #spede .cell.bad    { background: #f8d7da; border-color: #dc3545; }
  .muted { color:#555; font-size:.95rem }
</style>



<h1>Staattisen Nginx-sivun testailua</h1>
<p>SQL-palvelimen aika: <span id="t" class="time">...</span></p>

<p><p></p>
<img src="LH2.gif" alt="Linux harjoitus GIF" width="400">
<p><p></p>

<!-- ===== REPLACEMENT: Speden pelit -reaktiopeli ===== -->
<div id="scoreboard">
  Pisteet: <span id="score">0</span> — Ennätys: <span id="best">0</span>
</div>

<div id="spede">
  <div class="cell" data-dir="UP">▲</div>
  <div class="cell" data-dir="LEFT">◀</div>
  <div class="cell" data-dir="RIGHT">▶</div>
  <div class="cell" data-dir="DOWN">▼</div>
</div>

<p id="hint" class="muted">Paina nuolta kun se syttyy! (myös näppäimistön nuolet käy)</p>

<div id="queue" style="margin-top:.25rem;font-size:1.2rem;"></div>
<!-- ===== REPLACEMENT END ===== -->


<script>
/* Ajan päivitys (nykyinen koodi) */
async function updateTime() {
  try {
    const r = await fetch('/time', {cache:'no-store'});
    if (!r.ok) throw new Error('HTTP ' + r.status);
    const j = await r.json();
    document.getElementById('t').textContent = j.time || 'virhe';
  } catch(e) {
    document.getElementById('t').textContent = 'virhe';
  }
}
updateTime();
setInterval(updateTime, 1000);
</script>

<script>
const cells = Array.from(document.querySelectorAll('#spede .cell'));
const scoreEl = document.getElementById('score');
const bestEl  = document.getElementById('best');
const hintEl  = document.getElementById('hint');
const queueEl = document.getElementById('queue');

let score=0, best=Number(localStorage.getItem('best_spede')||0);
bestEl.textContent = best;

const dirs = ['UP','DOWN','LEFT','RIGHT'];
const glyph = {UP:'▲',DOWN:'▼',LEFT:'◀',RIGHT:'▶'};
const freqs = {UP:880, RIGHT:660, DOWN:330, LEFT:440};

let running = false;
let queue = [];               // odottavat kohteet (FIFO)
let lastDir = null;           // ettei tule samaa peräkkäin
let period = 1000;            // 1 Hz alku
let genTimer = null;          // “tuottaja” joka lisää jonoon
let streak = 0;               // onnistumiset (kiihdytys joka 10.)
const MAX_Q = 5;              // kun jonon pituus ylittää, reset

// estä nuolilla sivun scroll
window.addEventListener('keydown', e=>{
  if (['ArrowUp','ArrowDown','ArrowLeft','ArrowRight',' '].includes(e.key)) e.preventDefault();
},{passive:false});

// näppäimet: Space = start/stop, nuolet = vastaus
window.addEventListener('keydown', e=>{
  if (e.key===' ') return toggleRun();
  if (!running) return;
  if (e.key==='ArrowUp')    hit('UP');
  if (e.key==='ArrowDown')  hit('DOWN');
  if (e.key==='ArrowLeft')  hit('LEFT');
  if (e.key==='ArrowRight') hit('RIGHT');
});
cells.forEach(c=>c.addEventListener('click',()=>{ if(running) hit(c.dataset.dir); }));

function playTone(dir, dur=0.12){
  try{
    window._actx = window._actx || new (window.AudioContext||window.webkitAudioContext)();
    if (_actx.state==='suspended') _actx.resume();
    const o=_actx.createOscillator(), g=_actx.createGain();
    o.type='sine'; o.frequency.value=freqs[dir]||440;
    g.gain.value=0.0001; o.connect(g); g.connect(_actx.destination);
    const t=_actx.currentTime;
    g.gain.exponentialRampToValueAtTime(0.2, t+0.02);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.start(t); o.stop(t+dur+0.02);
  }catch(_){}
}

function clearStates(){ cells.forEach(c=>c.classList.remove('active','good','bad')); }
function lightHead(){
  clearStates();
  const head = queue[0];
  if (!head) return;
  const el = cells.find(c=>c.dataset.dir===head);
  if (el) el.classList.add('active');
  playTone(head);
}
function renderQueue(){
  // näytä esim. 8 ensimmäistä
  queueEl.textContent = 'Jono: ' + queue.slice(0,8).map(d=>glyph[d]).join(' ');
}

function pickDir(){
  const choices = dirs.filter(d=>d!==lastDir);
  const d = choices[Math.floor(Math.random()*choices.length)];
  lastDir = d;
  return d;
}

function produceOnce(){
  queue.push(pickDir());
  renderQueue();
  if (queue.length===1) lightHead();      // jos jono oli tyhjä, sytytä uusi
  if (queue.length>MAX_Q) return miss();  // ei pysynyt tahdissa
}

function scheduleProducer(){
  clearInterval(genTimer);
  genTimer = setInterval(produceOnce, period);
  hintEl.textContent = `Tahti: ${(1000/period).toFixed(2)} Hz`;
}

function toggleRun(){
  running = !running;
  if (running){
    // start / restart
    queue = []; streak=0; period=1000; renderQueue();
    score=0; scoreEl.textContent=score;
    scheduleProducer(); produceOnce();   // tuota heti eka
    hintEl.textContent = `Käynnissä — Space = pysäytä`;
  } else {
    clearInterval(genTimer);
    clearStates();
    hintEl.textContent = `Pysäytetty — Space = käynnistä`;
  }
}

function hit(dir){
  const head = queue[0];
  const el = cells.find(c=>c.dataset.dir===dir);
  if (!head || !el) return;

  if (dir===head){
    el.classList.add('good');
    queue.shift(); renderQueue();
    score+=1; streak+=1; scoreEl.textContent=score;
    if (streak%10===0){        // joka 10. onnistuminen → nopeutus 10 %
      period = Math.max(250, Math.round(period*0.9));
      scheduleProducer();
    }
    lightHead();
  } else {
    el.classList.add('bad');
    miss();
  }
}

function miss(){
  // talleta ennätys
  if (score>best){ best=score; localStorage.setItem('best_spede',best); bestEl.textContent=best; }
  // resetoi mutta jätä peli “päällä” odottamaan uutta starttia
  clearInterval(genTimer); running=false;
  queue=[]; renderQueue(); clearStates();
  score=0; streak=0; period=1000; scoreEl.textContent=score;
  hintEl.textContent = 'Hups! Space = uusi yritys (alkaa 1 Hz)';
}
</script>

